# java-summary
write some java basic code.
写代码：
1。明确需求，我要做什么？
2。分析思路：我要怎么做？1，2，3。
3。确定步骤，每一个思路部分用到那些语句，方法和对象
4。 代码实现。用具体的java代码把思路体现出来

学习新技术的四点：
1。 该技术是什么？
2。 该技术有什么特点（使用注意）
3。 该技术怎么使用。 demo
4. 该技术什么时候用？ test
====================================================================================================
配置环境变量：让java jdk\bin目录下的工具，可以在任意目录下执行，原因是，将该工具所在目录告诉了系统，当使用该工具时，由系统帮我们去找制定的目录
==================================================================================================
javac命令和java命令做什么事情呢？
要知道java是分两部分的；一个是编译，一个是运行
javac: 负责是编译的部分，当执行javac时，会启动java的编译器程序。对指定扩展名的.java文件进行编译。
	   生成了jvm可以识别的字节码文件。也就是class文件，也就是java的运行程序
java: 负责运行的部分，会启动jvm，加载运行时所需的类库，并对class文件进行执行。	
====================================================================================================
一个".java"源文件中是否可以包含多个类(不是内部类)?有什么限制？
	可以， 但一个源文件中最多只能有一个公开类而且文件名必须和公开类的类名完全保持一致。
====================================================================================================
语句：
if switch do...while while for
1) 当判断固定个数的值的时候，可以使用if,也可以使用switch.
	但是建议使用switch,效率相当高。
2） 当判断数据范围，获取判断运行结果boolean类型时，需要使用if
3) 当某些语句需要执行很多次时，就用循环结构。 while 和 for 可以进行交互	

for循环执行顺序
	for(sta1; sta2; sta3){
		sta4;
	}
	1. 进入循环执行sta1;//只是进入的时候执行
	2. 执行sta2;//条件为真才执行sta4, 不然就跳出for循环了
	3. 执行sta4
	4. 执行sta3
	5. 再回到第2步开始执行
====================================================================================================

数组： 用于存储同一类型数据的一个容器。
	好处： 可以对该容器中的数据进行编码，从0开始。数组用于封装数据，就是一个具体的实体。
在java中表现一个数组的两种形式：
1。 元素类型[] 变量名 = new 元素类型[元素个数];
2。 元素类型[] 变量名 = {元素1，元素2...};
元素类型[] 变量名 = new 元素类型[]{元素1，元素2...};
// 二分查找法。 必须有前提：数组中的元素要有序
数组的倒序
	double scores[] = new double[] {2.0, 3.5, 8.9};
		//倒序
		for(int i=0; i<scores.length/2; i++){
			double temp = scores[i];
			scores[i] = scores[scores.length-1-i];
			scores[scores.length-1-i] = temp;
		}
		System.out.println(Arrays.toString(scores));
数组去重复
	1。 将数组遍历放入set集合中
	2。 新建一个数组， 遍历set集合， 将其赋值给数组
		int a[] = new int[] { 10, 10, 20, 30, 40, 40, 50, 70, 20 };
		Set set = new HashSet();
		for (int i = 0; i < a.length; i++) {
			set.add(a[i]);
		}
		int b[] = new int[set.size()];
		Iterator iterator = set.iterator();
		for (int j = 0; j < b.length; j++) {
			if (iterator.hasNext()) {
				b[j] = (Integer) iterator.next();
			}

		}
		Arrays.sort(b);
		System.out.println(Arrays.toString(b));

数组的扩容分为以下三步：
	1， 定义一个新数组，分配更大的内存空间
	2， 将原数组中的全部内容复制到新数组中
	3， 让原数组引用新数组
eg:
	int a[] = {10, 20, 30};
	int b[] = new int[5];  //step1
	for(int i=0; i< a.length; i++){
		b[i] = a[i];  //step2                                   step2: system.arraycopy(a, 0, b, 0, a.length);
	}
	a = b; //step3
	a[3] = 40;
	a[4] = 50;
	
重载：
变长参数(int...numbers)
方法的递归：指方法在运行过程中直接或间接调用自身而产生的重入现象。
		在使用递归算法时，必须有一个明确的递归结束条件，称为递归出口。 
====================================================================================================
java分了5片内存
1： 寄存器：最快的存储区，因为它位于不同于其他存储区的地方（处理器内部），但是处理器的数量极其有限，所以寄存器根据需求进行分配。
2： 本地方法区
3： 方法区
4： 栈  存储的都是局部变量（函数中定义的变量，函数上的参数，语句中的变量）
		只要数据运算完成所在的区域结束，该数据就会被释放
5： 堆  用于存储数组和对象，也就是实体。啥是实体？ 就是封装多个数据
		1） 每一个实体都有内存首地址值
		2） 堆内存中的变量都有默认的初始化值。因为数据类型不同，值也不一样。
		3） 垃圾回收机制
====================================================================================================
面向对象：
特点： 1）将复杂的事情简单化
	 2）面向对象将以前的过程中的执行者，变成了指挥者
	 3）面向对象这种思想是符合现在人们思考习惯的一种思想

过程和对象在我们的程序中是如何体现的呢？过程其实就是函数    对象是将函数等一些内容进行了封装

总结： 开发时，记住，属性是用于存储数据的，直接被访问，容易出现安全隐患，所以，类中的属性通常被私有化，并对外提供公共的访问方法/get set方法
注意： 类中怎么没有定义主函数呢？
	主函数的存在，仅为该类是否需要独立运行，如果不需要，主函数是不用定义的。
	主函数的解释： 保证所在类的独立运行，是程序入口，被jvm调用
====================================================================================================
封装：是指隐藏对象的属性和实现细节，提供公共方法对其访问
	好处：将变化隔离； 便于使用； 提高重用性； 安全性
	封装原则：将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问

	this:
	代表对象，就是所在函数所属对象的引用
	注意: 用this调用构造函数，必须定义在构造函数的第一行。因为构造函数是用初始化的，所以初始化动作一定要执行。否则编译失败。 
====================================================================================================
main: 主函数特定的名称
	（String[] args）:主函数的参数，使一个字符串数组类型的参数，jvm调用main方法时，传递的实际参数是new String[0]
	
静态代码块， 构造代码块， 构造函数同时存在时执行顺序

静态类和静态方法
	如果一个类要被声明为static的， 只有一种情况， 就是静态内部类。
	
	静态内部类实际上与普通类（即类名必须与文件名一样的顶级类）一样，只是静态内部类在某一类的内部定义而已，既然是类，要想使用必须就实例化。
	概念上与静态变量，静态方法就是不一样， 不要被静态两字所迷惑。（不要以为凡是静态的东西都不需要实例化就可以直接使用， 静态内部类是由区别的）
	而且只有静态内部类，而没有静态类（顶级类）的概念。
	
	静态方法只能访问静态成员，实例方法可以访问实例和静态成员。 之所以不允许静态方法访问实例成员变量，是因为实例成员变量是属于某个对象的。静态方法中也不能使用关键字this
====================================================================================================
继承：
	1： 提高了代码的复用性
	2： 让类与类之间产生了关系，提供了另一个特征多态的前提。
	
	父类的由来： 其实是由多个类不断向上抽取共性内容而来的
	java中对于继承，java只支持单继承。
	为什么不支持多继承呢？
	因为当一个类同时继承两个父类时，两个父类中有相同的功能，那么子类对象调用该功能时，运行哪一个呢？因为父类中的方法存在方法体。
	
	继承的概念：
	1： 自动拥有父类的属性和方法
	2: 父类的private[访问限制符]， 子类不能访问
	3： protected: 同一个包， 或者继承关系中直接访问
	4： 覆盖： 子类对父类的方法进行重写
		1） 方法名称一致
		2） 参数类型一致
		3） 返回类型一致
		@override
		注释方法内覆盖的方法
		子类不得比父类抛出更多，更大的异常
		子类不得比父类有更小的访问限制符
		注意： 参数可以使用final修饰
=====================================================================================================
构造函数：
	如果类中定义了大量的属性，在实例化类的对象后，往往需要挨个为属性赋值。 为了减少不必要的重复，java提供了构造函数这一特殊的方法来进行对对象的初始化工作。
	构造函数有如下语法特征：
	1。 构造函数不能定义返回值类型
	2。 构造函数名必须与类名相同
	3。 构造函数无法手工调用，只有在实例化对象是由系统自动调用
	4。 构造函数可以重载，java会根据实例化对象时传递的参数决定调用哪一个构造函数
	5。 没有函数的构造函数称为缺省构造函数，java编译器会为类生成缺省构造函数，但开发者自己定义构造函数（无论有参还是无参），编译器将不再生成缺省构造函数。
static + 方法
通过类名调方法， 因为静态方法与对象无关，也就无法访问对象的属性和方法，静态方法只能调用同为静态属性和方法;同时，不能在静态方法中使用this关键词
static 块（静态块）  不能在静态方法中使用this关键字
====================================================================================================
多态;
满足多态的三个前提： 1。 继承关系， 2。 父类引用指向子类对象 3。 方法的覆盖
====================================================================================================
垃圾回收机制：
分代垃圾收集：

java虚拟机在运行时会将内存分为多个区域，其中三个典型的区域：栈，堆，全局区
重载与重写：
重载： 
重写：
数组和集合：
数组在应用中有长度限制，并且没有提供比较方便的维护方法，java集合就解决这个难题 
数组的长度在使用前必须确定，一旦确定不能改变。
=====================================================================================================
进程： 一个运行中的程序就是一个进程，进程是操作系统分配cpu资源与内存资源的最小单位。 
线程： 通过代码可以创建， 销毁的是线程， 进程内部可以拥有一个或多个线程， 操作系统将资源分配给进程后，进程再将资源分配给线程，可以认为进程是线程的容器。
多线程
	java中实现多线程有两种方法： 继承Thread 类， 实现Runnable接口，在程序开发中只要是多线程，肯定永远以实现Runnable接口为主，
	因为实现Runnable接口相比继承Thread类有如下优势：
	1： 可以避免由于java的单继承特性而带来的局限性
	2： 增强程序的健壮性，代码能被多个线程共享，代码与数据时独立的
	3： 适合多个相同程序代码的线程区处理同一资源的情况。
	下面是实现Runnable接口实现的多线程程序
	public class MyThread implements Runnable{
		private int ticket = 5;
		public void run(){
			for(int i = 0; i < 10; i++){
				if(ticket > 0){
				System.out.println("ticket = " + ticket);
				}
			}
		}
	}
	
	public class RunnableDemo{
		public static void main(String[] args){
			MyThread my = new MyThread();
			new Thread(my).start;
			new Thread(my).start;
			new Thread(my).start;
		}
	}
 

sleep() 和 wait() 有什么区别？（葵花宝典13）
线程的生命周期：
	新建  就绪   堵塞   死亡
==================================================================================================
创建对象和销毁对象
	考虑用静态工厂方法代替构造器
	静态构造方法和构造器不同的第一大优势在于，他们有名称。
=================================================================================================================

读（InputStream）  <外存 --> 内存 >                             写（OutputStream）    < 内存 -->  外存 >
visibility 能见度
; 增强代码的可读性和整洁性  缺少分隔符，一条语句的结束就成了另一条语句的开始。
======================================================================================================
在javascript中， 复杂的运算通过Math对象的属性定义的函数和常量来实现
Math.pow(2,22);  // => 2 的 22次幂
Math.round(.6);   //1.0: 四舍五入
Math.ceil(.6); //1.0 :  向上求整
Math.floor(.3)	// 0.0 : 向下求整 
Math.abs(-33); //33 : 绝对值
Math.max(2,3,4);
Math.min(2,3,4);
Math.random() // 生成一个大于等于0小于1的伪随机数 
Math.PI()     //3.1415926（pai）  圆周率
Math.E    //e: 自然对数的底数
Math.sqrt(3)   //3 的平方根
Math.sin(0)  //三角函数。  还有 Math.cos(); Math.atan()等
Math.log(10) // 10的自然对数 
Infinity 无穷大
payment.innerHTML = monthly.toFixed(2); //四舍五入到小数点后两位     
				//toFixed(2); //四舍五入到小数点后两位    
				//toExponential()指数计数法   var a = 123456.789; a.toExponential(3); =>1.235e+5;
				//toPrecision() 根据指定的有效数字位数将数字转化成字符串。如果有效数字的位数小于数字整数位数部分的位数，则转化成指数形式。
				//a.toPrecision(7);   =>123456.8 
				
NaN,   NaN 和其他值都是不相等的，包括它自己！通过 x!=x 来判断x是否是NaN， 只有x为NaN时，只隔这个表达式才为true。
==========================================================================================================	
正则表达式
regular expression

典型的调用顺序是 

 Pattern p = Pattern.compile("a*b");
 Matcher m = p.matcher("aaaaab");
 boolean b = m.matches();
=====================================================================================================
url uri urn 之间的区别
uri；Uniform Resource Identifier 统一资源标识符， 提供了一个简单，可扩展的资源标识方式。
===================================================================================================================
java的输入/输出  java Input/Output   java/IO

 除了使用"\\"以外，还可以使用"/",因为"//"是"\"的转义符。
java/IO 最重要的五个类和一个接口， 分别是 File, OutputStream, InputStream（字节）, Writer, Reader（字符）, 一个接口： Serializable

在程序设计过程中，绝大多数应用程序都是使用字符流读取或写入“文本数据”。因为字符流支持Unicode标准字符集的各种字符集，而字节流仅支持"ISO 8859-1(lATIN-1)"字符集。 
因此处理"文本数据"时，建议使用字符流。

提示： 字符流不能处理二进制文件的主要原因： 是因为字符流对象在读写文件时会解释和处理文件中的特殊字符， 例如回车符（＼0x0d）, 换行符(\0x0a)　, 文件结束符(\0x1a)等。
特别地，当他碰到文件结束符是就会认为文件已结束，而二进制文件可能在文件中间就出现文件结束符。

File 
	isDirectory
public boolean isDirectory()测试此抽象路径名表示的文件是否是一个目录。 
返回：
当且仅当此抽象路径名表示的文件存在且 是一个目录时，返回 true；否则返回 false 
====================================================================================================================================


 
 
 
 
  Exception:
 five word: try catch finally throw throws
	try{}: 跟踪有问题的代码
	catch{}: 异常捕获块
	finally{}: 必定会执行的语句块
	throw: 抛出一个异常对象
	throws: 声明方法的异常类型
异常中需要注意的：
	1。 尽量在 try 中不要 return
	2. return 是在栈内存的一个小空间存储， try 中的return 不是跳出方法体， 而是在内存中存储 a 的值。
	3。 后面的 return 是取 try 中的return 存储的值。 
受检查异常： 要求代码必须对发生的异常进行处理  （直接或间接继承自Exception的异常类为受检异常）
非受检查异常： 可以不进行处理 （直接或间接继承自RuntimeException异常类为非受检异常）
常见的集中异常：
NullPointException
ClassCastException
RunTimeException 
SQLPException
IllegalArgumentException   方法参数不正确
====================================================================================================
//什么是容器？ 	容器 就是存放数据的一个集合。

java collection FrameWork (JCF) 集合:
	ArrayList 与 LinkedList 的区别
	Set 和 Map : 看到这两个首先想到是什么？ 都不允许重复，Set 不允许重复的进入， Map 覆盖了重复的。
	set不能存放重复元素（用对象的equals() 方法来区分元素是否重复）。MAP保存键值对映射，映射关系可以使一对一也可以是一对多。
	Set 和 Map 容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存储时间复杂度为O（1），而基于排序树版本的实现在
	插入和删除元素时会按照元素或元素的键（KEY）构成排序树从而达到排序和去重的效果。
	
	
	HashMap 和 HashTable 的区别
	1。 HashMap 线程不安全， KEY value 都可为null
		HashTable  线程安全， key value 不能为null, 为null时，编译通过，执行报错。  报一个NullPointException
	HashMap 与 TreeMap 的区别
	HashMap 排列无序 
	TreeMap 有序（红黑树 ） 
	
	Set集合被设计为用于快速判断某元素在集合是否存在，所以Set集合最重要的方法是contains。 set集合的不同实现类部差异很大。
====================================================================================================	
	JDBC的用途： 1。 同一个数据库建立连接
			  2。 向数据库发送sql语句
			  3。 处理数据库返回的结果集
			
	JDBC 的六部曲:
	1. 加载驱动
	2。 创建连接
	3。 创建preparedStatement
	4. 执行sql语句
	5。 处理返回结果集
	6。 关闭流 
====================================================================================================
使用hibernate完成页面的分页功能：
分页：
	1。 每页显示行数   10行
	2。 表中总行数
	3。 总页数      （总行数/10）
	4。 分页        （第几行，10）：（当前页-1）*10
Oracle 分页** 分页的一般公式： (pageRow*(currentPage-1)+1, pageRow*currentPage)
mySql分页** a: limit 起始行， 行数
		   b: limit 1, 5 (1 到 5 行， 从 1 开始 )
分页方法的核心思想是一致的：
	1。 如何传递参数
	2。 需要传递哪些参数
	3。 如何计算这些参数
	4。如何依据参数值来确定显示数据的范围
	**** 在分页中进行分页参数的计算时， 要特别注意临界值的计算方法。
 
分页需要传递的参数有：起始位置， 一页多少行
====================================================================================================
	servlet 的作用： 接受数据， 控制跳转， 逻辑处理
	代码拒绝万能类
	类的职责单一性原则
====================================================================================================
hibernate 
hibernate 的作用： 就是实现持久化对象和数据库中表之间的映射。
	
Object-Relational Mapping
主要的功能：实现实体域对象的持久化并封装数据访问的细节
本质： 本质是将数据从一种形式转换到另一种形式。
涉及的两个关键点： 对对象的操作和对关系型数据库的访问。
什么是持久化技术？ 什么是持久层技术？
持久化技术： 将内存中数据保存到磁盘上的操作。  （ 也就是掉电后数据还在 ）  
持久层技术： 用于进行对象的持久化操作
J2EE 
JINI（java intelligent network infrastructure） 可以使人们简单的使用网络设备和网络服务。
jini作用： 简化与网络的交互性。
SNMP（简单网络管理协议）  
====================================================================================================
OSIV 模式 open session in view 
org.hibernate.LazyInitializationException:could not initalize proxy-no session/session closed
产生的原因： session 关闭的太早
解决方案： 延迟 session 的关闭，[页面时间]
流程： 创建一个过滤器
	 打开session
	 doFilter()
	 关闭 session()
====================================================================================================
N+1问题：
Query query = session.createQuery("from Address");
List<Address> list = query.list();
Iterator<Address> it = query.iterator(); // 取出所有的内容
1) 查询表中所有的id                                           (1)
2)                                                         (N)
3)延迟加载
	a) 加载id
	b) id---> 具体内容
4） session 缓存是有限的
====================================================================================================
Spring
spring 的核心： 就是一个轻量级的容器，为软件开发提供全方位支持的应用型框架。
容器: 就是符合某种规范的 能够提供一系列服务的管理器，其他人员可以利用容器所提供的服务来方便的实现某些特殊功能。
IOC AOP
IOC: (控制反转) IOC本质是实现了对象之间的依赖关系的转移。 
AOP: (Aspect-oriented programming)面向切面编程： 面向切面编程是面向对象编程的一个补充。
oop: 面向对象的编程
切面的方法：
@before  
@after      
@around
切点表达式： execution(*com.sxt.service.impl.*.*(..));

Spring-test , junit4 , 注解:
测试重点： service   dao
1. 引入spring-test 框架
2. DOM4J
3. assert(实际值， 预期值); 
====================================================================================================
HTML
实体Entitile引用 
&amp;                &
&nbsp；               空格
&lt;                 <
&gt;                 >
&quot               ...
====================================================================================================
CSS
CSS 语法
CSS 语法由三部分构成：选择器、属性和值：
selector {property: value}
选择器 (selector) 通常是你希望定义的 HTML 元素或标签，属性 (property) 是你希望改变的属性，并且每个属性都有一个值。属性和值被冒号分开，
并由花括号包围，这样就组成了一个完整的样式声明（declaration）：

记得写引号
提示：如果值为若干单词，则要给值加引号：     p {font-family: "sans serif";}

类选择器
td.fancy {
	color: #f60;
	background: #666;
	}
在上面的例子中，类名为 fancy 的表格单元将是带有灰色背景的橙色。

.fancy td {
	color: #f60;
	background: #666;
	}
在上面这个例子中，类名为 fancy 的更大的元素内部的表格单元都会以灰色背景显示橙色文字。（名为 fancy 的更大的元素可能是一个表格或者一个 div）

====================================================================================================
javaScript
document.write字段是标准的javaScript命令， 用来向页面写入输出
javaScript表单验证  可用来在数据被送往服务器之前对HTML表单中这些输入数据进行验证
javaScript注解
运算符    ==   vs ===
==：值相等
===：值和类型都相等
...数组
1. var a = new Array();
2. 遍历
	for(var temp in a){
		alert(a[temp]);
	}
	数组越界不报错，因为是弱数据类型会自动添加。
	建议： 在数组尽量不要越界，否则后期维护难。
	
获得js对象[html 元素]方法
1） document.getElementById("id"); 取得html中的元素
	a。 document.getElementById("id") html中的元素
	b。 对象.属性---> 属性的值
	c。 id： 元素的id属性
	d。 document---> html 文档
2） document.getElementsByName("name")
	a. name 属性的值一致
	b. 取多个元素
	c. 数组
	d. for(var index in 数组)
	
js 的表单验证
1） 正则表达式
	a。 var pattern = /^正则表达式$/
	b. 概念： 判定输入是否合法
	c. 基本的正则表达式
		1。 [0-9] 0~9 的一个数字 (\d)
		2. [abcdefg] 选取a 或 b 或 c ....
		3. + : 一个或 n 个 
		4。 . : 任意字符
		5。 {n} : 字符只能出现 n 次
表单提交判定：
<form onsubmit="return 函数（）" />
document.getElementById("id").innerHTML="文本内容";    
====================================================================================================
jquery
取元素， 
	选择符， 
		基本： tag  id  class  *   ,  document对象（6个） 	   
		层次
			空格    层次
			>      父子
			+      next()
			~(波浪线) nextAll()
		属性：   [attr]
		过滤： 检索过滤，   内容过滤，    表单元素过滤
		游历：
			parent()  child()
			prev()     next()
			prevAll()  nextAll()
			siblings()  
			andSelf()
			find()      从children中找出 parent.find(':input');

jquery方法：
css()
1. css("css属性","属性的值");  设置属性
2. css("css属性");  读取属性			
	attr(); 读取或设置属性
	1） attr("属性","值");  设置
	2） attr("属性"); 读取

注意：            $("div:odd") 与 $("div  :odd")之间的区别
 :nth-child(n)    下标从一开始；
 :first 与   :first-child 的区别
 
 jquery 与js 的区别
 1。 js 按页面的解析顺序加载
     jquery 加载html的结构
	 
============================================================
javascript和jquery的区别
js，即JavaScript
在1995年时，由Netscape公司的Brendan Eich，在网景导航者浏览器上首次设计实现而成。因为Netscape与Sun合作，Netscape管理层希望它外观看起来像Java，因此取名为JavaScript
JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型
jQuery
jQuery是一个兼容多浏览器的javascript库，核心理念是write less,do more(写得更少,做得更多)
jquery 就对javascript的一个扩展，封装，就是让javascript更好用，更简单。人家怎么说的来着，jquery就是要用更少的代码，漂亮的完成更多的功能。
 ===================================================================================================
 HTTP协议 （超文本传输协议）
	协议剖析
		结构： 5大类别的状态码
			400-499; 客户端错误
				400  Bad Request
				401  Unauthorized , 要求客户端提供认证信息
				403  Forbidden   拒绝请求
				404   Not Found
				405  Method Not Allowed 不允许此请求方式
			500-599	服务器错误
				500  Internal Server Error
				505  Version Not Supported 不支持Http版本
====================================================================================================
servlet: 运行在服务器端的java程序
生命周期：
核心API： HttpServletRequest(获取输入) 
		HttpservletResponse（生成响应）

交流协作： forward转发
		include包含
		redirect重定向

过滤器Filter
监听器Listener
职责： 获取前端数据
	 控制转发
	 逻辑处理
====================================================================================================
JSP
优点： 编写方便    （以HTML为静态模板，内嵌java代码，实施局部替换）
	 部署快捷  （无需在web.xml中进行相关配置； 无需重新发布和重启servlet/jsp容器）

与servlet的关系：jsp运行时转化成servlet(jsp是html外观的servlet)
生命周期： 
	1. jsp _jsp.java[Servlet] 转化（1。2）： 就是web容器将JSP文件转化成一个包含了servlet类定义的java源文件。
	2. java--class
	3. class--JVM   编译：把在转化阶段创建的java源文件编译成类文件。
	4. instantiate （实例化）
	5. init    (jspInit   _jspInit)
	6. service  (_jspService)
	7. destroy  (jspDestroy    _jspDestroy)

JSP中有哪些要素：
	静~~HTML为底版：
		HTML Element                
		DOM
		CSS 
		JavaScript          RegExp
	动~~
		指令 Directive <%@ %>     指导命令Translation过程
		脚本 JavaScript<%   %>
		注释 Comment <%--   --%>
		动作 Standard Action  <jsp:userBean>
		<c:foreach>  ${param.usename}    (JSTL/EL和自定义标签库)
======
	Directive指令：
		<%@ %>指令    指导命令Translation过程//编译
		3条指令：
			<%@ page language="java" contentType="text/html; charset=utf-8"%>
			<%@ taglib prefix="c" uri="/jstl/c"%>
			<%@ taglib prefix="fmt" uri="/jstl/fmt"%>
			<%@ taglib prefix="hase" uri="/hase"%>
			<%@ taglib uri="ES-formprocessing-taglib" prefix="es-html" %>
			<%@ taglib uri="ES-formprocessing-errormessages-taglib" prefix="error" %>
			<%@ include file="OrderCapSalesComplianceDetail.jsp" %>  编译期静态文件合并
				<jsp:include page="Banner.jsp" flush="true">
					<jsp:param name="page" value="View / Amend Structure Maintenance" />
				</jsp:include>  运行期动态调用
	Scriptlet脚本 <%%>
		<%%>脚本
		<!% %>声明
			在类的位置与_jspService方法同级
			不能直接使用 隐含变量（JSP九大内置对象）
		<%= %> 表达式语句   结尾不能加；
		
		EL    操作符  关系: > < >= <= == != 或 [gt lt ge le eq ne]
		
		$jsp标签
		
post方式解决乱码问题
request.setCharacterEnconding("utf-8");
response.setContentType("text/html; charset=utf-8");

get方式解决乱码问题
页面（utf-8） --> ISO-8859-1 --> utf-8
name = new String(name.getBytes("iso-8859-1","utf-8"));


<c:forEach var="每个变量名称" items="要迭代的list" varStatus="每个对象的状态" begin="循环从哪开始" end="循环到哪结束" step="循环的步长">
	循环要输入的东西
</c:forEach>
<c:forEach>标签具有以下一些属性
var: 迭代参数的名称。在迭代体中可以使用的变量的名称，用来表示每一个迭代变量。 类型为String
items: 要进行迭代的集合。对于它所支持的类型将在下面进行讲解
varStatus = "status": 迭代变量名称，用来表示迭代的状态，可以访问到迭代自身的信息。//status.count

====================================================================================================
session: 客户与服务器之间交互的对象
	对象有权限：
	http协议： 无记忆性
	session 特点：
	1） 服务器创建的对象
	2） 时效性，默认时间（30分钟）
	Session 的几个问题：
	1）创建在服务器   request.getSession();
	2）session 的大小是有限的，不能存储大数据
====================================================================================================
XML
简介：
	XML 指可扩展标记语言
	XML 是一种标记语言，很类似HTML
	XML 的设计宗旨是传输数据，而非显示数据
	XML 标签没有被预定义。你需要自行定义标签
	XML 被设计具有自我描述性
	XML 是W3C的推荐标准
xml的主要作用：数据交换和信息配置。

**现在很多时髦的软件已经开始将配置文件写成了json（JavaScript Objection Notation）格式，我们已经强烈的感受到xml的另一个功能也逐渐被业界抛弃。
====================================================================================================
2016-10-13
javaScript Date(日期) 对象、
====================================================================================================
sql
在sql语句中函数不能跟where同时使用， 这时会用到having
eg:	SELECT Customer,SUM(OrderPrice) FROM Orders
	GROUP BY Customer
	HAVING SUM(OrderPrice)<2000
ucase（）;将某一字段的字母全部变成大写
UCASE 函数把字段的值转换为大写// LCASE()小写
SELECT UCASE(LastName) as LastName,FirstName FROM Persons
====================================================================================================
PBG2-------------Bond Order Enquiry       
/UOEESWeb/WebContent/jsp/trading/Bond/BondOrderEnquiry.jsp 
/UOEESWeb/resources/UOEES/eventmapping/Event_BondBuyOrder.xml               Bo Yu Rain Liu
页面跳转的几种方式：
1。 window.location
2. <meta  refresh******>
3. <a></a>
4. form表单  action="url"
5. <iframe src="引用一个窗口">
====================================================================================================
po和pojo的区别
po: persisent object
	持久对象实际上必须对应数据库中的entity.
pojo: pure old java object or plain ordinary java object or what ever
      是由new创建，由GC回收。但是持久对象是由insert数据库创建，由数据库delete删除的。基本上持久对象生命周期和数据库密切相关
	  
七个概念辨析：
po: persistent object
pojo : pure old java object
vo : value object
dto : data transfer object
entity:
domain object <域对象> /domain object model
====================================================================================================
数据库隔离级别
READ_UNCOMMITTED
READ_COMMITTED
REPEATABLE_READ
SERIALIZABLE
从上往下，级别越来越高，并发性越来越差，安全性越来越高
数据在高并发下所产生的问题：
1， Dirty Read（脏读）： 事务A读取了事务B未提交的数据，并在这个基础上又做了其他操作。
2. Unrepeatable Read（不可重复读）： 事务A读取了事物B已提交的更改数据。
3. Phantom Read (幻读)： 事物A读取了事务B已提交的新增数据。
原子性，隔离性，不可重复性，一致性（老大）
============================================================================================
调换字体的显示台被隐藏了，如何把它显示出来，。
=====================================================================================================
获取当前的路径   String currentPath =  System.getProperty("user.dir");
========================================================================================
方法覆盖应注意：子类方法的方法名，参数类型要与父类一致 ；子类的返回类型与父类兼容； 访问修饰符范围不小于父类访问修饰符访问才是合法的方法覆盖。
======================================================================================================
基本类型优先于装箱基本类型
	基本类型与装箱基本类型之间的区别：1。 基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性。
							 2。 基本类型只有功能完备的值，而每个装箱基本类型除了它对应基本类型的所有功能之外，还有个非功能值： null.
							 3. 基本类型通常比装箱基本类型更节省时间和空间。如果不小心，这三点区别都会让你陷入麻烦之中。 
==========================================================================================================
遵守普遍接受的命名惯例
	局部变量名称的字面命名惯例与成员名称类似，只不过它也允许缩写，单个字符与短字符的序列的意义取决于局部变量所在的上下文环境，例如：i, xref, houseNumber
	
	执行某个动作的方法通常用动词或动词短语来命名，例如append, drawImage. 对于返回boolean 值得方法，其名称往往以单词"is"开头，很少用has,后面跟名词或名词短语，
	或者任何具有形容词功能的单词和短语，例如： isDigit, isProbablePrime, isEmpty, isEnable
======================================================================================
异常应该只用于异常的情况下； 它们永远不应该用于正常的控制流。

方法的重载就是构建器。






 
